\section{Related Work}

The methods we used in our implementation of an OS fingerprinter were rather ``old school'' techniques. In addition to using TCP window size and TTL values in the IPv4 headers, other implementations can use far more sophisticated or combinations of techniques for determining OS name and version.  For example, nmap uses a combination of techniques that, when used together, give a good guess as to which OS is being targeted.  Fydor, nmap's author, uses the following two techniques (in addition to the one we used) for OS fingerprinting. 

\subsection{FIN Probe}

The basic idea of Fydor's technique was to send a packet which was crafted to with an invalid set of options \cite{defeating_nmap}.  These options typically result in some sort of error on the receiving party.  Each response, like with TCP window size, will differ depending on the OS in question.  With FIN probing, we craft a packet and set the FIN flag without an SYN or an ACK flag.  This configuration results in an error which we can analyze to determine the OS.  The correct response (according to RFC 793) is to not respond, however, many broken implementations will send something like a RST packet.

\subsection{IPID Sampling}

This method focus on what is called the IPID field of the TCP/IP packet.  Every packet contains a number in this field and it is used to identify the fragment of data its payload is carrying.  Some operating systems simply increment this number, while others choose a random number \cite{defeating_nmap}.  Again, by analyzing these disparities, we are able to deduce the TCP/IP implementation that the remote machine in question is running.